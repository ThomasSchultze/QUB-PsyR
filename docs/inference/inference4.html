<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The one-factorial ANOVA – QUB-PsyR</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-93b28c2596283b6e178f0a7aa3af3e88.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../images/QUBlogoWsmall.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">QUB-PsyR</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-intro" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Intro</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-intro">    
        <li>
    <a class="dropdown-item" href="../intro/intro1.html">
 <span class="dropdown-text">R and RStudio</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../intro/intro2.html">
 <span class="dropdown-text">Running Code in R</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../intro/intro3.html">
 <span class="dropdown-text">Objects and Functions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../intro/intro4.html">
 <span class="dropdown-text">Data Frames and Lists</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../intro/intro5.html">
 <span class="dropdown-text">Saving and Loading Data</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-working-with-r-objects" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Working with R Objects</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-working-with-r-objects">    
        <li>
    <a class="dropdown-item" href="../working/working1.html">
 <span class="dropdown-text">Binary Operators</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../working/working2.html">
 <span class="dropdown-text">Functions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../working/working3.html">
 <span class="dropdown-text">Numerical Indexing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../working/working4.html">
 <span class="dropdown-text">Logical Indexing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../working/working5.html">
 <span class="dropdown-text">R Packages</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-statistical-inference" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Statistical Inference</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-statistical-inference">    
        <li>
    <a class="dropdown-item" href="../inference/inference0.html">
 <span class="dropdown-text">A Primer on Statistical Inference</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference1.html">
 <span class="dropdown-text">The t-test</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference2.html">
 <span class="dropdown-text">The Chi²-test</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference3.html">
 <span class="dropdown-text">Correlations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference4.html">
 <span class="dropdown-text">One-factorial Analysis of Variance</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference5.html">
 <span class="dropdown-text">Two-factorial Analysis of Variance</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference6.html">
 <span class="dropdown-text">Repeated measures and mixed ANOVAs</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference7.html">
 <span class="dropdown-text">Simple linear regression</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference8.html">
 <span class="dropdown-text">Multiple linear regression</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../inference/inference9.html">
 <span class="dropdown-text">Multi-level models</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-data-visualisation" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Data Visualisation</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-data-visualisation">    
        <li>
    <a class="dropdown-item" href="../graphs/graphs0.html">
 <span class="dropdown-text">Preface</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../graphs/graphs1.html">
 <span class="dropdown-text">Histograms</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../graphs/graphs2.html">
 <span class="dropdown-text">Scatterplots</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../graphs/graphs3.html">
 <span class="dropdown-text">Violin plots</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-data-wrangling" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Data Wrangling</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-data-wrangling">    
        <li>
    <a class="dropdown-item" href="../wrangling/wrangling0.html">
 <span class="dropdown-text">Preface</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../wrangling/wrangling1.html">
 <span class="dropdown-text">Extracting rows and columns</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The one-factorial ANOVA</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The Analysis of Variance (ANOVA) is a generalisation of the <span class="math inline">\(t\)</span>-Test. It is used to test the difference between two or more means against zero. When comparing groups using ANOVA, we partition the total variance inherent to the data (collapsed across all groups) into the variance between groups (i.e., the variance of the group means) and the variance within groups.</p>
<section id="the-foundations-of-anova" class="level2">
<h2 class="anchored" data-anchor-id="the-foundations-of-anova">The foundations of ANOVA</h2>
<p>A key concept in ANOVA is that of the <strong>sum of squares</strong>. To understand the sum of squares, let us consider the formal definition of the variance <span class="math inline">\(\sigma^2\)</span> of a variable, which looks as follows:</p>
<p><span class="math display">\[\sigma^2_x = \frac{1}{n} \times \underbrace{\Sigma{(x_i - \bar{x})^2}}_\text{sum of squares}\]</span></p>
<p>From this equation, we can see that the variance of the variable <span class="math inline">\(x\)</span> is the product of two components. One is the <strong>sum of squares</strong>, that is, the sum of the squared deviations of each observation <span class="math inline">\(x_i\)</span> from their mean <span class="math inline">\(\bar{x}\)</span>. The second factor simply divides this sum of squares by the number of observations <span class="math inline">\(n\)</span>.</p>
<p>When we estimate the true variance <span class="math inline">\(\sigma^2_x\)</span> from data we collected, using the formula above produces a slight bias. Specifically, our estimate of the true variance will be systematically too low. To arrive at an unbiased estimate, we need to divide the sum of squares by <span class="math inline">\(n-1\)</span> instead of <span class="math inline">\(n\)</span>, leading to the following formal definition of the <strong>estimate of the variance</strong> <span class="math inline">\(\hat{\sigma}^2_x\)</span>:</p>
<p><span class="math display">\[\hat{\sigma}^2_x = \frac{1}{n-1}\Sigma{(x_i - \bar{x})^2}\]</span></p>
<div class="alert alert-success">
<p><strong>Fun fact</strong>: Dividing a sum of squares by its degrees of freedom yields the so called <strong>mean squares</strong>. The mean squares follow a <span class="math inline">\(\chi^2\)</span>-distribution with the respective degrees of freedom.</p>
</div>
</section>
<section id="the-logic-of-the-anova" class="level2">
<h2 class="anchored" data-anchor-id="the-logic-of-the-anova">The logic of the ANOVA</h2>
<p>The whole idea of ANOVA rests on the fact that the variance can be partitioned into the sum of its parts. This is also true for the the <strong>sum of squares</strong>. As a very basic rule, we can state that:</p>
<p><span class="math display">\[SS_{total} = SS_{between} + SS_{within}\]</span></p>
<p>Here, <span class="math inline">\(SS_{total}\)</span> is a measure of the total variability of a variable, <span class="math inline">\(SS_{between}\)</span> represents that part of the total variability that is due to differences of the group means, and <span class="math inline">\(SS_{within}\)</span> represents the part of the total variability that results from heterogeneity within the groups.</p>
<p>Similar to the <span class="math inline">\(t\)</span>-test, ANOVA is a signal to noise ratio, where we treat variability between groups as the signal and variability within groups as the noise. The test statistic we use to test for significant mean differences between groups is the <span class="math inline">\(F\)</span>-value, which is formally defined as:</p>
<p><span class="math display">\[F = \frac{VAR_{between}}{VAR_{within}}=\frac{\frac{SS_{between}}{df_{between}}}{\frac{SS_{within}}{df_{within}}} = \frac{MS_{between}}{MS_{within}}\]</span></p>
<p>In the formula above, <span class="math inline">\(MS\)</span> is the corresponding <strong>mean squares</strong>.</p>
<div class="alert alert-success">
<p><strong>Fun fact</strong>: Based on the formula above, we can easily derive that <span class="math inline">\(F\)</span> is the ratio of two <span class="math inline">\(\chi^2\)</span>-distributed variables. Both the numerator and the denominator constitute a sum of squares divided by its degrees of freedom. That is also the reason why the <span class="math inline">\(F\)</span>-distribution has two degrees of freedom, one for the numerator and one for the denominator.</p>
</div>
<p>How we compute the mean squares depends on the type of ANOVA we run and the number of groups we compare in it.</p>
<p>However, we can state generally how we compute the different <strong>sum of squares</strong>. First of all, let’s remember how we compute the total sum of squares, <span class="math inline">\(SS_{total}\)</span>:</p>
<p><span class="math display">\[SS_{total} = \sum_{i=1}^{N} (x_i - \bar{x})^2\]</span></p>
<p>The total sum of squares represent the sum of the squared deviation of all <span class="math inline">\(N\)</span> observed data points from the grand mean <span class="math inline">\(\bar{x}\)</span>. Now lets look at the formula for <span class="math inline">\(SS_{between}\)</span>.</p>
<p><span class="math display">\[SS_{between} = \sum_{j=1}^{J} n_j \times (\bar{x}_j - \bar{x})^2\]</span></p>
<p>Here, <span class="math inline">\(J\)</span> is the number of groups we compare, and <span class="math inline">\(n_j\)</span> is the sample size of group <span class="math inline">\(j\)</span>. For the <span class="math inline">\(SS_{between}\)</span> we pretend that there is no variance within the <span class="math inline">\(J\)</span> groups at all. Each observation is represented by its group’s mean <span class="math inline">\(\bar{x}_j\)</span>, and we compute the variability as the difference of these group means from the grand mean <span class="math inline">\(\bar{x}\)</span>. Therefore, the <span class="math inline">\(SS_{between}\)</span> isolates the between-group part of the total variability of <span class="math inline">\(x\)</span>. Let’s now turn to the <span class="math inline">\(SS_{within}\)</span>.</p>
<p><span class="math display">\[SS_{within} = \sum_{j=1}^{J} \sum_{i = 1}^{n_j} (x_{ij} - \bar{x}_j)\]</span></p>
<p>Again, <span class="math inline">\(J\)</span> is the number of groups we compare, and <span class="math inline">\(n_j\)</span> is the sample size in group <span class="math inline">\(j\)</span>. The <span class="math inline">\(x_{ij}\)</span> refers to the <span class="math inline">\(i\)</span>th observation in group <span class="math inline">\(j\)</span>. For the <span class="math inline">\(SS_{within}\)</span>, we pretend that there is no variance between groups at all. We do so by substituting the <strong>grand mean</strong> for the respective group means <span class="math inline">\(\bar{x}_j\)</span>. Thus, the <span class="math inline">\(SS_within\)</span> isolates the within-group variability of <span class="math inline">\(x\)</span>.</p>
<p>The final thing we need to understand before we can delve into the actual ANOVAs is the <span class="math inline">\(F\)</span>-statistic. As we have seen above, we compute <span class="math inline">\(F\)</span> as a ratio of the <span class="math inline">\(MS_{between}\)</span> and the <span class="math inline">\(MS_{within}\)</span>. This ratio is interesting in several ways:</p>
<ol type="1">
<li>Since the <span class="math inline">\(SS_{between}\)</span> usually has much fewer degrees of freedom than the <span class="math inline">\(SS_{within}\)</span>, the variability between groups does not have to be nearly as large as the variability within groups to produce a large <span class="math inline">\(F\)</span>-value.</li>
<li>The more groups we compare, the lower the <span class="math inline">\(F\)</span>-ratio will be, ceteris paribus. However, this does not necessarily mean that it becomes more difficult to detect significant mean differences. The more groups we compare, and the more numerator degrees of freedom our test has, the lower the critical <span class="math inline">\(F\)</span>-value past which we consider a result statistically significant.</li>
<li>The larger our total sample, the more denominator degrees of freedom we have, and the smaller the noise becomes in our signal-to-noise ratio, ceteris paribus. This makes intuitive sense: as the samples size increases, our measurement becomes more precise, making it easier to detect differences between group means.</li>
</ol>
<div class="alert alert-success">
<p><strong>Fun fact</strong>: If we use an ANOVA to compare two means, we effectively run a <span class="math inline">\(t\)</span>-test but discard its ability to indicate the direction of the effect.</p>
<p>In such cases <span class="math inline">\(F = t^2\)</span>, and the <span class="math inline">\(p\)</span>-value of both tests will be identical if we run a <span class="math inline">\(t\)</span>-test assuming equal variances.</p>
</div>
<p>ANOVAs come in various flavours. In the following, we will look at some of them, namely:</p>
<ul>
<li>one-factorial ANOVAs (between-subjects)</li>
<li>two-factorial ANOVAs (between-subjects)</li>
<li>repeated-measures ANOVAs (within-subjects)</li>
<li>mixed ANOVAs (at least one between and one within factor)</li>
</ul>
</section>
<section id="one-factorial-anova" class="level2">
<h2 class="anchored" data-anchor-id="one-factorial-anova">One-factorial ANOVA</h2>
<p>In a one-factorial ANOVA, we compare two or more group means such that we consider each group to represent one level of the same grouping variable or factor <span class="math inline">\(A\)</span>. The underlying model assumes that the true mean of each of the <span class="math inline">\(j\)</span> groups <span class="math inline">\(\mu_j\)</span> is the sum of the true grand mean <span class="math inline">\(\mu\)</span> and the effect of the <span class="math inline">\(j\)</span>th level of factor <span class="math inline">\(A\)</span> on that mean. We call these effects <span class="math inline">\(\alpha_j\)</span>.</p>
<p><span class="math inline">\(\mu_j = \mu + \alpha_j\)</span></p>
<p>This is equivalent to:</p>
<p><span class="math inline">\(\alpha_j = \mu_j - \mu\)</span></p>
<p>In other words, the effect of the <span class="math inline">\(j\)</span>th level of factor <span class="math inline">\(A\)</span> is the difference between the true group mean <span class="math inline">\(\mu_j\)</span> and the true grand mean <span class="math inline">\(\mu\)</span>. Accordingly, if <span class="math inline">\(\mu_j\)</span> exceeds <span class="math inline">\(\mu\)</span>, the respective <span class="math inline">\(\alpha_j\)</span> is positive.</p>
<p>The Null hypothesis is that all group means are equal. This equivalent to stating that all <span class="math inline">\(\alpha_j\)</span> are zero. The alternative hypothesis is that not all group means are equal or, put differently, that at least one of the <span class="math inline">\(\alpha_j\)</span> is non-zero.</p>
<p><span class="math inline">\(H0:\alpha_j = 0 \quad \forall j\)</span></p>
<p><span class="math inline">\(H1: \lnot H_0\)</span></p>
<p>Running ANOVAs in base R tends to be very clunky because R is more centered around classic regression models. Therefore, we won’t be using base R to run ANOVAs, but instead use an R package called <em><code>afex</code></em> (Analysis of Factorial Experiment). That means, we need to install and load <em><code>afex</code></em> first.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages("afex")</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(afex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once we have done that, we can start doing ANOVAs with one of several functions:</p>
<ul>
<li><strong><code>aov_car()</code></strong></li>
<li><strong><code>aov_4()</code></strong></li>
<li><strong><code>aov_ez()</code></strong></li>
</ul>
<p>The three functions serve the same goal and do the same things, but they differ in terms of the syntax. The function <strong><code>aov_car()</code></strong> uses syntax that is most closely related the the (clunky) base R version of ANOVA. In contrast, <strong><code>aov_4()</code></strong> uses syntax based on the popular <em><code>lme4</code></em> package that is widely used for the analysis of generalised mixed models. Thus, this function is ideally suited for users who are already familiar with <em><code>lme4</code></em>. Finally, <strong><code>aov_ez()</code></strong> uses a completely string-based format, that is, it does not require a formula type object as a function argument. The advantage of <strong><code>aov_ez()</code></strong> is that it is very convenient and easy to handle (thus the suffix “ez”). This comes at the cost of flexibility. The lack of a formula means that we are stuck with a full ANOVA model. The other two functions technically allow us to specify models that omit certain main effects or interactions. However, since we will rarely want to run these incomplete models, this is a drawback that usually causes no hassles. In the following, we will focus on the <strong><code>aov_ez()</code></strong> function and leave exploration of the other functions to the discretion of the reader.</p>
<p>Here are the most important function arguments of <strong><code>aov_ez()</code></strong>:</p>
<ul>
<li><code>id</code> (necessary): a character value indicating the name of the variable that contains our subject ID</li>
<li><code>dv</code> (required): another character value; the name of the variable containing the data the group means of which we want to compare</li>
<li><code>data</code> (required): an R object of type data frame containing the data we want to analyse</li>
<li><code>between</code> (optional): a character string or character vector indicating the name(s) of the variable(s) constituting the between-subjects factor(s) of our design; default is NULL meaning that there are no between-subjects factors</li>
<li><code>within</code> (optional): a character string or character vector indicating the name(s) of the variable(s) constituting the within-subjects factor(s) of our design; default is NULL meaning that there are no within-subjects factors</li>
<li>`covariate*: a character value or vector indicating the name(s) of the covariate(s) in our analysis</li>
<li><code>factorize</code> (optional): a logical value; determines if the between- and within-subject variables are turned into factors prior to the analysis; default is TRUE; if our design has at least one covariate, we need to set this to FALSE and make sure that all factors are defined as such manually</li>
<li><code>anova_table</code> (optional): a list of further arguments passed to the function; the ones we may be interested in are <code>es</code> (effect size; default is ‘ges’, which yields <span class="math inline">\(\eta^2\)</span> as an effect size measure, but we can switch it to ‘none’ or to ‘pes’, which yields <span class="math inline">\(\eta^2_p\)</span>) and <code>correction</code> (non-sphericity correction method; default is ‘none’, but we can switch it to ‘GG’ for the Greenhouse-Geisser or ‘HF’ for the Huynh-Feldt correction)</li>
</ul>
<p>For the purpose of running a one-factorial between-subjects ANOVA, we can disregard some of the function arguments shown above. The only ones we need are <code>id</code>, <code>dv</code>, <code>between</code>, and possibly <code>anova_table</code> in case we want to obtain the effect size.</p>
<div class="alert alert-danger">
<p>Now that we want to do ANOVAs, it is time to talk about <strong>factors</strong>. In R, <strong>factors</strong> are a special type of vector that contain both values and labels for those values. The different values of vectors are considered to be categories. Factors are important because the ANOVA-function we use here requires its between- and within-subject variables to be factors.</p>
<p>We can create a factor using the <strong><code>factor()</code></strong> function by feeding it the following function arguments:</p>
<ul>
<li><code>x</code>: a vector we want to turn into a factor</li>
<li><code>levels</code>: a vector containing all possible values the factor can take</li>
<li><code>labels</code>: a character vector assigning a label to each level of the factor</li>
</ul>
</div>
<p>Lets look at an example, in which we test whether the means of three groups are equal or not. First, we need to create some data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-overflow-wrap code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># create a data frame containing data from 30 subjects in three groups of 10 each; here, "id" is the subject identifier, "cond" is the between-subjects grouping variable, and "dv" contains the outcome variable we want to compare between groups</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>my_df <span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># subject ID</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">ID =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">30</span>,      </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># between-subjects-factor 'cond'</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">cond =</span> <span class="fu">factor</span>(  </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rep</span>(<span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">each =</span> <span class="dv">10</span>),</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">levels =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">'control'</span>, <span class="st">'treatment1'</span>, <span class="st">'treatment2'</span>)),</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># outcome variable 'dv'</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">dv =</span> <span class="fu">c</span>(</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">12</span>,  <span class="dv">9</span>, <span class="dv">14</span>, <span class="dv">11</span>, <span class="dv">15</span>, <span class="dv">13</span>, <span class="dv">15</span>, <span class="dv">18</span>, <span class="dv">12</span>), <span class="co"># dv data for control</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">c</span>( <span class="dv">9</span>,  <span class="dv">7</span>, <span class="dv">15</span>, <span class="dv">14</span>,  <span class="dv">8</span>,  <span class="dv">7</span>, <span class="dv">16</span>, <span class="dv">13</span>, <span class="dv">11</span>, <span class="dv">16</span>), <span class="co"># dv data for treatment1</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">c</span>(<span class="dv">12</span>, <span class="dv">11</span>, <span class="dv">11</span>,  <span class="dv">9</span>,  <span class="dv">8</span>, <span class="dv">13</span>,  <span class="dv">8</span>,  <span class="dv">6</span>, <span class="dv">14</span>,  <span class="dv">7</span>)) <span class="co"># dv data for treatment2</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can inspect how the data frame looks using the <em>head</em> function.</p>
<div class="alert alert-warning">
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  ID    cond dv
1  1 control 10
2  2 control 12
3  3 control  9
4  4 control 14
5  5 control 11
6  6 control 15</code></pre>
</div>
</div>
</div>
<p>Now that we have some data, we can run the ANOVA. The syntax looks as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-overflow-wrap code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">aov_ez</span>(<span class="at">id =</span> <span class="st">'ID'</span>, <span class="at">between =</span> <span class="st">'cond'</span>, <span class="at">dv =</span> <span class="st">'dv'</span>, <span class="at">data =</span> my_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is what the output in the console looks like:</p>
<div class="alert alert-warning">
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Contrasts set to contr.sum for the following variables: cond</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Anova Table (Type 3 tests)

Response: dv
  Effect    df  MSE    F  ges p.value
1   cond 2, 27 9.27 2.44 .153    .106
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1</code></pre>
</div>
</div>
</div>
<p>As we can see, R displays an ANOVA table in the console along with some additional information. The output is preceded by a message (this is NOT an error message; the code ran properly). This message informs us that the <strong><code>aov_ez()</code></strong> function set the contrast type for our factor ‘cond’ to ‘contr.sum’. What this means is that the contrast underling our factor was forced into effect coding because that is the format that ANOVAs use. We don’t need to concern ourselves with that.</p>
<p>Next, R will tell us that this output is an ANOVA table based on type-3 sum of squares. Type-3 sums of squares are what most statistics packages use. If your knowledge of statistics is so advanced that you can make an informed decision that you would prefer type-2 sums of squares, you can change it by setting the <code>type</code> function argument to 2.</p>
<p>Now for the important bits. R shows us what the response variable in our model is, namely ‘dv’. Below that information, it displays the ANOVA table. Because we ran a one-factorial ANOVA; this table contains only one row. Here, we can see the name of the between-subjects factor (<em>effect</em>), the numerator and denominator degrees of freedom for its <span class="math inline">\(F\)</span>-value (<em>df</em>), the mean squares of the effect (<em>MSE</em>), the <span class="math inline">\(F\)</span>-value, the generalised <span class="math inline">\(\eta^2\)</span> as a measure of the effect size, and the <span class="math inline">\(p\)</span>-value.</p>
<p>In our example, the mean difference is not statistically significant, which means that we cannot reject the null hypothesis. In other words, we cannot say whether the true means between the three groups differ.</p>
<div class="alert alert-info">
<p>Similar to the <span class="math inline">\(\chi^2\)</span>-test, the <span class="math inline">\(F\)</span>-test we use in an ANOVA is always a one-tailed test because it is based on squared variables. Therefore, the test has no ‘direction’ as a <span class="math inline">\(t\)</span>-test would.</p>
<p>Why is this important? Sometimes, we might encounter a scientific article, in which the authors state that they ran a ‘one-tailed’ ANOVA test, but what they do in those articles is simply the divide their <span class="math inline">\(p\)</span>-value by 2. This practice (often encountered when the regular <span class="math inline">\(p\)</span>-value lies between .05 and .10) rests on the erroneous belief that all statistical tests are - per default - two-tailed and can, therefore, also be run as a one-tailed test with slightly greater power.</p>
</div>
</section>
<section id="disentangling-significant-effects-in-anovas" class="level2">
<h2 class="anchored" data-anchor-id="disentangling-significant-effects-in-anovas">Disentangling significant effects in ANOVAs</h2>
<p>In the example above, we had to retain the Null hypothesis because the analysis did not show evidence that the three means were different from each other. In those cases, there is no need for further analyses. However, things look a bit different when the ANOVA yields a significant result. Let’s look at an example.</p>
<p>In this example, we will compare two treatments and one control condition with data for 30 participants in each condition. The data is stored in a data frame called <em>my_df2</em>. Here is what the data looks like (we use the function <strong><code>head()</code></strong> on the data frame to have R show us the first 6 lines).</p>
<div class="alert alert-warning">
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>  ID    cond  dv
1  1 control  88
2  2  treat1 119
3  3  treat2 119
4  4 control 103
5  5  treat1 103
6  6  treat2 137</code></pre>
</div>
</div>
</div>
<p>We now run the ANOVA on the data. Other than before, we will define the result of the analysis as a new R object. This will make it easier for us to disentangle the effect later on. Here is the syntax:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-overflow-wrap code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># run a one-factorial ANOVA and save its results as a new R object</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>model1 <span class="ot">=</span> <span class="fu">aov_ez</span>(<span class="at">id =</span> <span class="st">'ID'</span>, <span class="at">dv =</span> <span class="st">'dv'</span>, <span class="at">between =</span> <span class="st">'cond'</span>, <span class="at">data =</span> my_df2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will now see a new object called “model1” in the <strong>Environment</strong>. R will tell us that this object is a list. Entering the new object’s name as syntax will show us the result of the ANOVA just as if we had called the function as is instead of defining it as a new object. Here is the console output:</p>
<div class="alert alert-warning">
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Anova Table (Type 3 tests)

Response: dv
  Effect    df   MSE         F  ges p.value
1   cond 2, 87 89.48 22.91 *** .345   &lt;.001
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '+' 0.1 ' ' 1</code></pre>
</div>
</div>
</div>
<p>As we can see, the effect of the factor “cond” in our fictional data is statistically significant. We can now state - with the usual confidence - that the means of the three groups are not equal. However, we cannot say anything else. Since an ANOVA uses the squared test statistic <span class="math inline">\(F\)</span>, we have no information on the direction of the mean differences, nor do we know which means differ. Thus, we need further analyses to get a clear picture of the mean differences the ANOVA detected.</p>
<div class="alert alert-info">
<p>As a useful - if somewhat brutish - metaphor, think of an ANOVA as firing a shotgun into think fog. A statistically significant effect means that we hit something, but we do not know what we hit. In order to find that out we need to venture into the fog and have a closer look.</p>
<p>(Credit for this metaphor goes to Prof.&nbsp;Dieter Heyer)</p>
</div>
<p>In order to disentangle a significant effect in an ANOVA with three or more groups, we need to run <strong>post-hoc</strong> analyses. There are many different ways to run such post-hoc analyses. Here, we will focus on <strong>post-hoc contrasts</strong>.</p>
<section id="post-hoc-t-tests" class="level3">
<h3 class="anchored" data-anchor-id="post-hoc-t-tests">Post-hoc t-tests</h3>
<p>Before we delve into <strong>post-hoc</strong> contrasts, it is worth mentioning that one easy way to disentangle significant effects in an ANOVA is running <span class="math inline">\(t\)</span>-tests to compare the means of the groups. We already know how to do this, namely by using the <strong><code>t.test()</code></strong> function.</p>
<p>However, there are three downsides to using simple <span class="math inline">\(t\)</span>-tests. First, they are less powerful than contrasts because their estimate of the error variance is based on only a part of the total sample. Second, if we want to control the type-I error rate by adjusting for multiple comparisons, we need to do so manually (this may be easy for Bonferroni’s method, but more challenging for less conservative adjustment methods). Third, as the number of groups we compare in an ANOVA increases, so does the number of possible pairwise comparisons. In fact, the number of comparisons is <span class="math inline">\((k^2-k)/2\)</span>, that is, it grows exponentially. Therefore, the amount of code we need to write also increases accordingly.</p>
</section>
<section id="pairwise-comparisons-using-contrasts" class="level3">
<h3 class="anchored" data-anchor-id="pairwise-comparisons-using-contrasts">Pairwise comparisons using contrasts</h3>
<p>An alternative to running individual <span class="math inline">\(t\)</span>-tests is to do pairwise comparisons using post-hoc contrasts. A contrast is a weighted average of the group means <span class="math inline">\(\bar{x}_j\)</span> of the <span class="math inline">\(J\)</span> groups we compare.</p>
<p><span class="math display">\[\hat{\psi} = \sum_{j=1}^{J} c_j \bar{x}_j\]</span></p>
<p>It must satisfy the condition that the weights <span class="math inline">\(c_j\)</span> add to zero:</p>
<p><span class="math display">\[\sum_{j=1}^{J} c_j = 0\]</span></p>
<p>The standard error of a contrast <span class="math inline">\(\hat{\psi}\)</span> is computed based on <strong>all data</strong>. That is why contrasts are usually more powerful than run-og-the-mill <span class="math inline">\(t\)</span>-tests. The standard error is defined as:</p>
<p><span class="math display">\[S_{\hat{\psi}} = \sqrt{MS_{within} \sum_{j=1}^{J} \frac{c_j^2}{n_j}}\]</span></p>
<p>Dividing a contrast <span class="math inline">\(\hat{\psi}\)</span> by its standard error <span class="math inline">\(S_{\hat{\psi}}\)</span> yields a variable that follows a <span class="math inline">\(t\)</span>-distribution with <span class="math inline">\(N-J\)</span> degrees of freedom, where <span class="math inline">\(N\)</span> is the total sample size, and <span class="math inline">\(J\)</span> is the umber of groups.</p>
<p><span class="math display">\[\frac{\hat{\psi}}{S_{\hat{\psi}}} \sim t_{N-J}\]</span> Testing a contrast comes down to running a one-sample <span class="math inline">\(t\)</span>-test to test (for example):</p>
<p><span class="math inline">\(H_0: \hat{\psi} = 0\)</span></p>
<p><span class="math inline">\(H_1: \hat{\psi} \ne 0\)</span></p>
<p>If we want to analyse contrasts in R, we need another R package called <em><code>emmeans</code></em>. This package contains a function called <strong><code>emmeans()</code></strong> (yes, it has the same name as the package) that allows us to run a contrast analysis. Let’s have a look at the <strong><code>emmeans()</code></strong> function. When we call it to analyse contrasts, we need to specify a few arguments:</p>
<ul>
<li><code>object</code> (required): an R object containing the results of an ANOVA (good thing we saved our ANOVA as an R object).</li>
<li><code>spec</code> (required): a character string or vector containing the name(s) of the grouping variable(s) in our data (in our example, the grouping variable is ‘cond’).</li>
<li><code>contr</code> (optional): a character value or list indicating the type of post-hoc comparisons; the default is NULL, but we can set it to “pairwise”, or we can define it as a list of vectors representing custom contrasts.</li>
<li><code>adjust</code> (optional): a character value indicating which method should be used to control for type-I error inflation due to multiple comparisons; default is “tukey” for Tukey’s method, but we can set it to “none” if we don’t want to adjust our <span class="math inline">\(p\)</span>-values, or we can choose a different adjustment method such as “holm” (the the Holm-Tukey method) or Bonferroni (for the Bonferroni correction).</li>
</ul>
<p>Let’s dive in an run pairwise comparisons on our ANOVA. We can tell the <strong><code>emmeans()</code></strong> function to run pairwise contrasts by setting the <code>contr</code> argument to “pairwise”. The function will then set up the following contrasts:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>control</th>
<th>treatment 1</th>
<th>treatment 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>contrast 1</td>
<td>1</td>
<td>-1</td>
<td>0</td>
</tr>
<tr class="even">
<td>contrast 2</td>
<td>1</td>
<td>0</td>
<td>-1</td>
</tr>
<tr class="odd">
<td>contrast 3</td>
<td>0</td>
<td>1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p>In the first example, we will go with the unadjusted <span class="math inline">\(p\)</span>-values. Let’s have a look at the code using the ANOVA model we saved as an R object above (“model1”). Here is the syntax.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-overflow-wrap code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># uncomment the next line to install the package emmeans</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages("emmeans")</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># load emmeans</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(emmeans)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"># pairwise comparisons without type-I error adjustment</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="fu">emmeans</span>(<span class="at">object =</span> model1, <span class="at">specs =</span> <span class="st">'cond'</span>,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">contr =</span> <span class="st">'pairwise'</span>, <span class="at">adjust =</span> <span class="st">'none'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>One we run the code above, R will return some information in the console. Here is what it looks like:</p>
<div class="alert alret-warning">
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Welcome to emmeans.
Caution: You lose important information if you filter this package's results.
See '? untidy'</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$emmeans
 cond    emmean   SE df lower.CL upper.CL
 control   97.1 1.73 87     93.7      101
 treat1   102.4 1.73 87     98.9      106
 treat2   113.3 1.73 87    109.9      117

Confidence level used: 0.95 

$contrasts
 contrast         estimate   SE df t.ratio p.value
 control - treat1    -5.23 2.44 87  -2.143  0.0349
 control - treat2   -16.20 2.44 87  -6.633  &lt;.0001
 treat1 - treat2    -10.97 2.44 87  -4.490  &lt;.0001</code></pre>
</div>
</div>
</div>
<p>The information we are interested in, is contained in the lower half of the output. There, we can see three contrasts, each comparing two of the three levels of our between-subjects variable ‘cond’. The output contains an estimate of the respective mean difference (this is the contrast value <span class="math inline">\(\hat{\psi}\)</span>) and its associated standard error (this is <span class="math inline">\(S_{\hat{\psi}}\)</span>). It also shows us the empirical <span class="math inline">\(t\)</span>-value for the contrast (dividing <span class="math inline">\(\hat{\psi}\)</span> by <span class="math inline">\(S_{\hat{\psi}}\)</span> yields this exact value) and its degrees of freedom. Here, we can see that the contrast has more degrees of freedom than a simple <span class="math inline">\(t\)</span>-test would have. Finally, the output contains the <span class="math inline">\(p\)</span>-value for each contrast. Based on this analysis, we would conclude that the effect of condition on our ANOVA was significant because all three means differ from one another.</p>
<p>Now let’s rerun the analysis while correcting for multiple comparisons. As mentioned above, we can choose from several methods that control type-I inflation. Let’s say we want to go with a classic and opt for Bonferroni’s method. This method adjusts the threshold at witch we consider an effect to be statistically significant. We now accept <span class="math inline">\(H_1\)</span> only if <span class="math inline">\(p &lt; \frac{\alpha}{k}\)</span>, where <span class="math inline">\(\alpha\)</span> is our tolerated type-I error level (e.g., <span class="math inline">\(\alpha = .05\)</span>), and <span class="math inline">\(k\)</span> is the number of post-hoc contrasts we test. What R does instead, is multiplying the unadjusted <span class="math inline">\(p\)</span>-values by <span class="math inline">\(k\)</span>. This makes it somewhat more convenient because we can keep comparing the now corrected <span class="math inline">\(p\)</span>-values to our usual tolerated type-I error level.</p>
<div class="alert alert-sucess">
<p>Are wondering what would happen if the unadjusted <span class="math inline">\(p\)</span>-value is already so large that multiplying it by the number of tests <span class="math inline">\(k\)</span> would propel it above 1? The simple answer is: nothing terrible: R caps the adjusted <span class="math inline">\(p\)</span>-values at 1 in order not to violate the laws of probability. While it is technically ‘wrong’, it is of little concerns to because the <span class="math inline">\(p\)</span>-values it concerns are so large they we would not accept <span class="math inline">\(H_1\)</span> in either the adjusted or unadjusted case.</p>
</div>
<p>Here is the code for the pairwise comparisons using Bonferroni’s method for controlling type-I error inflation (the only thing we need to change is the <code>adjust</code> argument).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-overflow-wrap code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pairwise comparisons with Bonferroni adjustment</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">emmeans</span>(<span class="at">object =</span> model1, <span class="at">specs =</span> <span class="st">'cond'</span>,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">contr =</span> <span class="st">'pairwise'</span>, <span class="at">adjust =</span> <span class="st">'bonferroni'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s have a look at the output in the console:</p>
<div class="alert alret-warning">
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>$emmeans
 cond    emmean   SE df lower.CL upper.CL
 control   97.1 1.73 87     93.7      101
 treat1   102.4 1.73 87     98.9      106
 treat2   113.3 1.73 87    109.9      117

Confidence level used: 0.95 

$contrasts
 contrast         estimate   SE df t.ratio p.value
 control - treat1    -5.23 2.44 87  -2.143  0.1048
 control - treat2   -16.20 2.44 87  -6.633  &lt;.0001
 treat1 - treat2    -10.97 2.44 87  -4.490  0.0001

P value adjustment: bonferroni method for 3 tests </code></pre>
</div>
</div>
</div>
<p>The information looks very similar to what we saw when we ran the uncorrected pairwise comparisons. The are only two differences: first, R will state at the bottom of the table that the <span class="math inline">\(p\)</span>-values were adjusted using Bonferroni’s method for three tests. Second, the <span class="math inline">\(p\)</span>-values differ. From looking at the first <span class="math inline">\(p\)</span>-value (the one for the contrast comparing treatment 1 to the control group) we can confirm that R has tripled the original <span class="math inline">\(p\)</span>-value (the difference at the fourth decimal is due to rounding). If we choose to use a Bonferroni correction for the post-hoc comparisons, our conclusions about the result of the ANOVA change slightly. Now, we would state - with the usual confidence - that the significant effect the ANOVA is due to the mean of the second treatment group differing from both the control group’s mean and that from treatment 1. However, we cannot say whether scores in treatment 1 differ from the control group.</p>
<p>Finally, let’s consider using a less conservative adjustment method, namely Tukey’s method, also known as Tukey’s honestly significant difference (HSD). In technical terms, HSD computes the critical mean difference for which a pairwise comparison is considered significant, and then judges each comparison by that difference. The test statistic <span class="math inline">\(q\)</span> follows the Studentised range distribution, the shape of which depends on the number of groups <span class="math inline">\(k\)</span> and the sample size <span class="math inline">\(N\)</span> (via the distribution’s degrees of freedom). Because the distribution of the <span class="math inline">\(q\)</span>-statistic considers the number of groups, the HSD adjusts for multiple comparisons. Again, the oly theing we need to change about our syntax is the <code>adjust</code> argument (see below):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-overflow-wrap code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pairwise comparisons using Tukey's method</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">emmeans</span>(<span class="at">object =</span> model1, <span class="at">specs =</span> <span class="st">'cond'</span>,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">contr =</span> <span class="st">'pairwise'</span>, <span class="at">adjust =</span> <span class="st">'tukey'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s again inspect the console output</p>
<div class="alert alret-warning">
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>$emmeans
 cond    emmean   SE df lower.CL upper.CL
 control   97.1 1.73 87     93.7      101
 treat1   102.4 1.73 87     98.9      106
 treat2   113.3 1.73 87    109.9      117

Confidence level used: 0.95 

$contrasts
 contrast         estimate   SE df t.ratio p.value
 control - treat1    -5.23 2.44 87  -2.143  0.0872
 control - treat2   -16.20 2.44 87  -6.633  &lt;.0001
 treat1 - treat2    -10.97 2.44 87  -4.490  0.0001

P value adjustment: tukey method for comparing a family of 3 estimates </code></pre>
</div>
</div>
</div>
<p>Once more, the output remains largely the same, the only difference being the <span class="math inline">\(p\)</span>-values and the statement about how the <span class="math inline">\(p\)</span>-values were adjusted. We can see that - similar to the Bonferroni - correction, R uses a multiplier on the <span class="math inline">\(p\)</span>-values rather than lowering the tolerated type-I error level, which makes life a little easier for us because we can still use our conventional <span class="math inline">\(\alpha\)</span>-level to asses the statistical significance of the tests. Although the Tukey correction is less severe than the Bonferroni correction, the result is qualitatively similar: we can confirm that treatment 2 scores differ from those of the other two conditions, but we cannot say whether scores in treatment 1 differ from those in the control group.</p>
</section>
<section id="custom-post-hoc-contrasts" class="level3">
<h3 class="anchored" data-anchor-id="custom-post-hoc-contrasts">Custom post-hoc contrasts</h3>
<p>The final way to run post-hoc tests we will consider here is to run custom contrasts. What this means is that we define ourselves how we want to compare the group means in case of a significant effect in the ANOVA. When using custom contrasts, we can choose how many comparisons we run, which means we want to compare, and how to compare them.The only thing we need to keep in mind is that the contrast weights must add to zero (R does not check this for us; the code will run even if the contrast sum does not add to zero, but the result may be nonsense).</p>
<p>For example, we could compare two group means (just as we did with the pairwise comparisons), but we could also test whether two groups differ from a third.</p>
<p>Let us go back to our ANOVA example and assume that we want to run two post-hoc tests. The first tests whether having any treatment leads to different scores than being in the control condition. The second tests whether the effectiveness of the two treatments differs. Here is what the two contrasts would look like:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>control</th>
<th>treatment 1</th>
<th>treatment 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>contrast 1</td>
<td>-1</td>
<td>+0.5</td>
<td>+0.5</td>
</tr>
<tr class="even">
<td>contrast 2</td>
<td>0</td>
<td>1</td>
<td>-1</td>
</tr>
</tbody>
</table>
<p>Let’s dissect that! For contrast 1, we compare the control group with the mean of the two treatment groups. In contrast 2, we compare only the two treatment groups; the 0 weight for the control condition means that its mean does not play any role in this contrast.</p>
<p>How do we tell R that we want to run custom contrasts? We can do so using the <code>contr</code> argument of the <strong><code>emmeans()</code></strong> function. To be specific, we need to define this argument as a list in which each element is one contrast.</p>
<p>When defining the list of contrasts, each contrast must be a numeric vector of length <span class="math inline">\(k\)</span>, where <span class="math inline">\(k\)</span> is the number of groups in the grouping variable that we fed into the <strong><code>emmeans()</code></strong> function (in our case 3). If we chose the wrong vector length, we will receive an error message. We also need to make sure that the sum of each contrast vector is zero (see above). Finally, we can (but do not have to) create these vectors as named elements of the list. Naming the vectors may lead to output that is slightly easier to make sense of.</p>
<p>Here, we need to decide whether we save the list of contrasts as a separate object or whether we feed the <strong><code>emmeans()</code></strong> function a call of the <strong><code>list()</code></strong> function (the result will be the same, so it is simply a matter of preference). Now let’s look at the R code.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-overflow-wrap code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Alternative 1: separate objects</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co"># create a list containing the custom contrasts</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>my_contrasts <span class="ot">=</span> <span class="fu">list</span>(</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">treat_vs_control =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>),</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">treat1_vs_treat2 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co"># run the custom post-hoc tests</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="fu">emmeans</span>(<span class="at">object =</span> model1, <span class="at">specs =</span> <span class="st">'cond'</span>,</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="at">contr =</span> my_contrasts, <span class="at">adjust =</span> <span class="st">'none'</span>)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="do">## Alternative 2: don't create a separate list</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="co"># run the custom post-hoc tests</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="fu">emmeans</span>(<span class="at">object =</span> model1, <span class="at">specs =</span> <span class="st">'cond'</span>,</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        <span class="at">contr =</span> <span class="fu">list</span>(</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>          <span class="at">treat_vs_control =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>),</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>          <span class="at">treat1_vs_treat2 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>)), </span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  <span class="at">adjust =</span> <span class="st">'none'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Running either version of the code will prompt R to test the contrasts and adjust the <span class="math inline">\(p\)</span>-values according to Bonferroni’s method (of course we could select a different adjustment method or turn if off by changing the <code>adjust</code> argument accordingly). We will receive the following console output:</p>
<div class="alert alert-warning">
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>$emmeans
 cond    emmean   SE df lower.CL upper.CL
 control   97.1 1.73 87     93.7      101
 treat1   102.4 1.73 87     98.9      106
 treat2   113.3 1.73 87    109.9      117

Confidence level used: 0.95 

$contrasts
 contrast         estimate   SE df t.ratio p.value
 treat_vs_control     10.7 2.12 87   5.066  &lt;.0001
 treat1_vs_treat2    -11.0 2.44 87  -4.490  &lt;.0001</code></pre>
</div>
</div>
</div>
<p>As we can see, R now returns a table with two contrast tests. Since we named the contrasts properly, it is easy to see what these contrasts tested. For each contrast, R will tell us the estimated mean difference, the associated standard error, and the degrees of freedom (<span class="math inline">\(n-k\)</span>, similar to the pairwise comparisons described above). It will also show us the <span class="math inline">\(t\)</span>-value and <span class="math inline">\(p\)</span>-value for each contrast.</p>
<p>In our example, both contrasts are significant. This means, we can state - with the usual confidence - that the ANOVA was significant because a) getting a treatment leads to different scores than getting no no treatment (control condition), and b) the treatments differ in effectiveness.</p>
<p>But what about multiple comparisons? So far, we have not corrected our custom contrasts for multiple comparisons, but we can do so if we want to. The only thing we need to consider is that we cannot use Tukey’s method as it is specific to pairwise comparisons (oddly enough, Tukey’s method won’t work even if we manually specify pairwise comparisons - if we want to use the HSD method,m we need to set the <code>contr</code> argument to “pairwise”).</p>
<p>To adjust for multiple comparisons, we can again specify the argument <code>adjust</code>. If we use custom contrasts, the default for this argument is actually “none”, but we can set it to “bonferroni” (for the classic Bonferroni correction) or “holm” (for the slightly lees conservative Holm-Bonferroni method) instead. Let’s go with Bonferroni. Here is the code:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-overflow-wrap code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># run the custom post-hoc tests using "contrast" and correct</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co"># for multiple comparisons using Bonferroni's method</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">emmeans</span>(<span class="at">object =</span> model1, <span class="at">specs =</span> <span class="st">'cond'</span>,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">contr =</span> <span class="fu">list</span>(</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>          <span class="at">treat_vs_control =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>),</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>          <span class="at">treat1_vs_treat2 =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>)), </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">adjust =</span> <span class="st">'bonferroni'</span> )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let’s look at the console output:</p>
<div class="alert alert-warning">
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>$emmeans
 cond    emmean   SE df lower.CL upper.CL
 control   97.1 1.73 87     93.7      101
 treat1   102.4 1.73 87     98.9      106
 treat2   113.3 1.73 87    109.9      117

Confidence level used: 0.95 

$contrasts
 contrast         estimate   SE df t.ratio p.value
 treat_vs_control     10.7 2.12 87   5.066  &lt;.0001
 treat1_vs_treat2    -11.0 2.44 87  -4.490  &lt;.0001

P value adjustment: bonferroni method for 2 tests </code></pre>
</div>
</div>
</div>
<p>As we can see, not much has changed in terms of statistical significance, which makes sense because the unadjusted <span class="math inline">\(p\)</span>-values were already very low. However, R now tells us at the bottom of the table that <span class="math inline">\(p\)</span>-values were adjusted using the Bonferroni method.</p>
<div class="alert alert-info">
<p>Custom contrasts are really useful because of their flexibility. They allow us to test very specific hypotheses. In fact, if we can state in advance which means in our design should differ (for example, because we have a strong theory to base our hypotheses on), we can technically skip the ANOVA altogether and instead run only the contrast tests. In those cases, we speak of a-priori contrasts.</p>
</div>
</section>
<section id="a-concluding-remark-on-post-hoc-comparisons" class="level3">
<h3 class="anchored" data-anchor-id="a-concluding-remark-on-post-hoc-comparisons">A concluding remark on post-hoc comparisons</h3>
<p>We started the journey into post-hoc analyses using the metaphor of the ANOVA as firing a shotgun into thick fog which - in case we hit something - necessitates wandering into the fog in order to find out what exactly we hit. As the examples above show, the answer to that crucial question depends on which post-hoc comparisons we run (simple <span class="math inline">\(t\)</span>-tests, pairwise comparison contrasts, or custom contrasts) and whether and how we control for type-I error inflation due to multiple comparisons.</p>
<p>When trying to disentangle a significant effect in an ANOVA, we may find ourselves faced with multiple options, each of which is valid and can be argued for convincingly. However, even subtle differences between these options may lead to qualitatively different conclusions. The practical advice here is to preregister exactly which tests we will run in case an ANOVA yields a significant result (ideally by providing the R code for the post-hoc analysis).</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>